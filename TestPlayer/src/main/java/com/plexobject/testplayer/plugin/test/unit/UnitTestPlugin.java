/* ===========================================================================
 * $RCS$
 * Version: $Id: UnitTestPlugin.java,v 2.36 2007/07/11 13:53:47 shahzad Exp $
 * ===========================================================================
 *
 * TestPlayer - an automated test harness builder
 *
 * Copyright (c) 2005-2006 Shahzad Bhatti (bhatti@plexobject.com)
 *
 * This program is free software; you can redistribute it and/or modify 
 * it under the terms of the GNU General Public License as published by 
 * the Free Software Foundation; either version 2 of the License, or 
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * The author may be contacted at bhatti@plexobject.com 
 * See http://testplayer.dev.java.net/ for more details.
 *
 */

package com.plexobject.testplayer.plugin.test.unit;
import com.plexobject.testplayer.plugin.*;
import com.plexobject.testplayer.plugin.test.*;
import com.plexobject.testplayer.*;
import com.plexobject.testplayer.util.*;
import com.plexobject.testplayer.events.*;
import com.plexobject.testplayer.tree.*;
import com.plexobject.testplayer.visitor.*;
import java.lang.reflect.*;
import java.io.*;
import java.util.*;
import java.text.*;
import java.beans.*;
import java.lang.reflect.*;
import org.apache.log4j.*;

/**
 * This class creates unit tests with mocks using junit, easymock and jmock.
 *
 * @author shahzad bhatti
 *
 * modification history
 * date         who             what
 * 9/17/05      SB              created.
 */
public class UnitTestPlugin extends BaseTestPlugin implements Visitor {
  public static final String TAG_DATA_DIR = "testplayer.unit.data.dir";
  public static final String TAG_FILE_PREFIX = "testplayer.unit.file.prefix";
  public static final String TAG_FILE_SUFFIX = "testplayer.unit.file.suffix";
  public static final String TAG_FILE_EXT = "testplayer.unit.file.ext";
  public static final String TAG_DEPTH = "testplayer.unit.depth";
  public static final String TOP_METHOD_KEY = "TOP_METHOD_KEY";


  /**
   * UnitTestPlugin - creates unit tests
   * @param context - application context
   */
  public UnitTestPlugin(ApplicationContext context) {
    super(
        context,
        context.getConfig().getProperty(TAG_DATA_DIR, "java/unit"),
        context.getConfig().getProperty(TAG_FILE_PREFIX, ""),
        context.getConfig().getProperty(TAG_FILE_SUFFIX, "Test"),
        context.getConfig().getProperty(TAG_FILE_EXT, ".java"),
        true,
        context.getConfig().getInteger(TAG_DEPTH)
        );
  }


  /**
   * creates suites of tests at the end of top level call.
   */
  protected void cleanup() throws Exception {
    writeSuites();
  }



  /**
   * initFile initialize output file
   * @param call - method call information
   * @param file - name of file
   */
  protected void initFile(
        MethodEntry call, 
        File file, 
        Object writer, 
        String pkg
        ) throws IOException {
    PrintWriter out = (PrintWriter) writer;
    if (pkg != null) out.println("package " + pkg + ";");
    String fileName = file.getName();
    String fileNameWithoutExt = fileName.substring(0, fileName.indexOf('.'));
    out.println("import junit.framework.*;");
    out.println("import java.beans.*;");
    out.println("import java.util.*;");
    out.println("import java.io.*;");
    out.println("import junit.framework.TestCase;");
    if (context.isjMockLibrary()) {
      out.println("import org.jmock.*;");
      out.println("import org.jmock.cglib.MockObjectTestCase;");
    } else {
      //out.println("import static org.easymock.classextension.EasyMock.createMock;");
      //out.println("import static org.easymock.classextension.EasyMock.replay;");
      //out.println("import static org.easymock.classextension.EasyMock.verify;");
      if (context.getJavaVersion() >= 1.5) {
        out.println("import static org.easymock.classextension.EasyMock.*;");
      }
      out.println("import org.easymock.*;");
    }

    out.println("import com.plexobject.testplayer.marshal.*;");
    out.println("import com.plexobject.testplayer.util.*;");

    out.println();
    out.println();
    out.println("/**");
    out.println(" * defines unit test for " + fileNameWithoutExt);
    out.println(" * @author - autogenerated by testplayer");

    // TestNG Annotations for Test Class
    if (context.getJavaVersion() >= 1.5) {
      out.println(" */"); 
      if (isTestFrameworkTestNG()) {
        out.println(" @org.testng.annotations.Test(" + Configuration.LF + "\t\tgroups = { \"unit-test\" }, " + Configuration.LF + "\t\talwaysRun = true, " + Configuration.LF + "\t\tenabled = true, " + Configuration.LF + "\t\tinvocationCount = 1, " + Configuration.LF + "\t\tsuccessPercentage = 100, " + Configuration.LF + "\t\ttimeOut = 10000, " + Configuration.LF + "\t\tthreadPoolSize = 1)");
      }
    } else {
      if (isTestFrameworkTestNG()) {
        out.println(" * @testng.test groups = \"unit-test\", alwaysRun = \"true\",enabled = \"true\", invocationCount = \"1\", successPercentage = \"100\", timeOut = \"10000\", threadPoolSize = \"1\"");
      }
      out.println(" */"); 
    }

    out.print("public class " + fileNameWithoutExt + " extends ");
    if (context.isjMockLibrary()) {
      out.println(" MockObjectTestCase {");
    } else {
      out.println(" TestCase {");
    }
    out.println("  IMarshaller marshaller = new " + context.getDefaultMarshaller().getClass().getName() + "();");
    if (isTestFrameworkJUnit4()) {
      out.println("  public static Test suite() {");
      out.println("    return new JUnit4TestAdapter(" + pkg + "." + fileNameWithoutExt + ".class);");
    } else {
      out.println("  public static TestSuite suite() {");
      out.println("    TestSuite suite = new TestSuite(\"" + pkg + "." + fileNameWithoutExt + "\");");
      out.println("    suite.addTestSuite(" + pkg + "." + fileNameWithoutExt + ".class);");
      out.println("    return suite;");
    }
    out.println("  }");
    out.println();
    out.println("  /**");
    out.println("   *"); 


    // TestNG Annotations for Setup Method
    if (context.getJavaVersion() >= 1.5) {
      out.println("   */");
      if (isTestFrameworkJUnit4()) {
        out.println("   @org.junit.Before");
      }
      if (isTestFrameworkTestNG()) {
        out.println("   @org.testng.annotations.Configuration(" + Configuration.LF + "\t\tbeforeTest = true," + Configuration.LF + "\t\tbeforeTestMethod = true," + Configuration.LF + "\t\tbeforeTestClass = true)");
        //out.println("   @org.testng.annotations.Configuration(beforeSuite = true)");
      }
    } else {
      if (isTestFrameworkJUnit4()) {
        out.println("   * @org.junit.Before");
      }
      if (isTestFrameworkTestNG()) {
        out.println("   * @testng.context.getConfiguration beforeTest = \"true\",beforeTestMethod = \"true\",beforeTestClass = \"true\"");
        //out.println("   * @testng.context.getConfiguration beforeSuite = \"true\"");
      }
      out.println("   */");
    }
    out.println("  public void setUp() {");
    out.println("  }");
    out.println("  public void testVaultFor" + fileNameWithoutExt + "() {");
    out.println("  }");
    out.println();




    out.println("  /**");
    if (context.getJavaVersion() >= 1.5) {
      out.println("   */");
      if (isTestFrameworkJUnit4()) {
        out.println("   @org.junit.After");
      }
      if (isTestFrameworkTestNG()) {
        out.println("   @org.testng.annotations.Configuration(" + Configuration.LF + "\t\tafterTest = true," + Configuration.LF + "\t\tafterTestMethod = true, " + Configuration.LF + "\t\tafterTestClass = true, " + Configuration.LF + "\t\tafterSuite = true)");
        //out.println("   @org.testng.annotations.Configuration()");
      }
    } else {
      if (isTestFrameworkJUnit4()) {
        out.println("   * @org.junit.After");
      }
      if (isTestFrameworkTestNG()) {
        out.println("   * @testng.context.getConfiguration afterTest = \"true\", afterTestClass = \"true\", afterTestMethod = \"true\"");
        //out.println("   * @testng.context.getConfiguration afterSuite = \"true\"");
      }
      out.println("   */");
    }
    out.println("  public void tearDown() {");
    out.println("  }");
    out.println();


    out.println("  public static void main(String[] args) {");
    out.println("    junit.textui.TestRunner.run(suite());");
    out.println("  }");
    out.println();
  }




  /**
   * before - receives notification before a method is invoked
   * @param context - application context
   * @param event - method call
   * @param writer - output
   */
  protected void before(
        ApplicationContext context, 
        MethodEvent event, 
        Object writer) 
        throws Exception {
    if (event == null) throw new IllegalArgumentException("No event");
    if (writer == null) throw new IllegalArgumentException("Failed to find writer for event " + event);
    super.before(context, event, writer);

    Tree tree = getTree();
    //logger.debug("********* Adding tree(" + tree.childrenCount() + " for call " + event.call);
    Node node = tree.add(event.call, event.call.getParent());
    if (node != null) {
      node.setAttribute("writer", writer);
    }
  }



  /**
   * after - receives notification after a method is invoked
   * @param context - application context
   * @param event - method call
   * @param writer - output
   */
  protected void after(
        ApplicationContext context, 
        MethodEvent event, 
        Object writer) 
        throws Exception {
    if (!event.call.isCompleted()) {
      //throw new IllegalStateException("Call " + event.call.toLongString() + " has not been completed");
      logger.warn("Skip test for " + event.call.toShortString() + ", because it has not been completed");
      return;
    }
    Tree tree = getTree();
    Node node = tree.find(event.call);
    logger.info("*************** Visiting " + node.childrenCount() + " children of " + event.call + "************");
    node.visitChildren(this);
    //tree.visitChildren(this);
  }


  /**
   * override cflowBegin to process method call processing before top level
   * method is invoked.
   * Note: This method is invoked before the abstract "before" method.
   */
  protected void cflowBegin(
        ApplicationContext context, 
        MethodEvent event, 
        Object writer) throws Exception {
    tmethodMap = new HashMap();
    methodStacks.set(new Tree());
  }

  /**
   * override cflowEnd to process method call processing after top level
   * method is invoked.
   * Note: This method is invoked after the abstract "after" method.
   */
  protected void cflowEnd(
        ApplicationContext context, 
        MethodEvent event, 
        Object writer) throws Exception {
    if (event == null) throw new IllegalArgumentException("No event");
    if (writer == null) throw new IllegalArgumentException("Failed to find writer for event " + event);
    //
    methodStacks.set(new Tree());
    tmethodMap = new HashMap();
  }


  /**
   * visit defines implementation of visitor interface
   */
  public void visit(Node node) {
    try {
      PrintWriter out = (PrintWriter) node.getAttribute("writer");
      if (out == null) throw new IllegalArgumentException("Failed to find writer for node " + node);
      ////////////////////////////////////////////////////////////////////
      MethodEntry call = (MethodEntry) node.getObject();
      if (!call.isPublic()) return;	// ??? 8/25/06
      if (!call.isCompleted()) {
	//throw new IllegalStateException("Call " + call.toShortString() + " has not been completed");
        logger.warn("Skip mock visit for " + call.toShortString() + ", because it has not been completed");
        return;
      }

      //
      String method = call.getMethodName();
      String tmethod = call.getMethodNameWithInvocationCount();
      synchronized (out) {
        List tmethods = (List) tmethodMap.get(out);
        if (tmethods == null) {
  	  tmethods = new ArrayList();
        } else if (tmethods.indexOf(tmethod) != -1) {
	   return;
        }
        tmethods.add(tmethod);
        tmethodMap.put(out, tmethods);
      }

      if (node.childrenCount() > 0) logger.debug("visit(" + call + ") children " + node.childrenCount() + "...");

      if (context.isSkipConstructorTest() && call.isConstructor()) {
         out.println("  /////////////////////////////");
         out.println("  //Skipping constructor test for " + call.getCallerName() + "." + method);
         out.println();
         out.println();
         return;
      }

      String fixtureName = createFixture(call, out);

      out.println("  /**");
      out.println("   *");
      out.println("   * " + call.toLongString());
      out.println("   * sub-calls " + node.childrenCount());


/*
      if (context.getJavaVersion() >= 1.5) {
	StackTraceElement[] ste = Thread.currentThread().getStackTrace();
	if (ste.length > 15) {
	  StackTraceElement last = ste[15];
          out.println("   * " + last.getFileName() + " " + last.getLineNumber());
        }
      }
*/


      // TestNG Annotations for Test Method
      if (context.getJavaVersion() >= 1.5) {
        out.println("   */"); 
        if (isTestFrameworkJUnit4()) {
          out.println("   @org.junit.Test"); //(expected=MyException.class)
        }
        if (isTestFrameworkTestNG()) {
          out.println("   @org.testng.annotations.Test(" + Configuration.LF + "\t\tgroups = { \"unit-test." + call.getCalleeNameWithoutPackage() + "\" })");
        }
      } else {
        if (isTestFrameworkJUnit4()) {
          out.println("   * @org.junit.Test");
        }
        if (isTestFrameworkTestNG()) {
          out.println("   * @testng.test groups = \"unit-test." + call.getCalleeNameWithoutPackage() + "\" })"); //dependsOnMethods = "m1"
        }
        out.println("   */"); 
      }

      //@org.testng.annotations.ExpectedExceptions(ElementNotFoundException.class)
      out.println("  public void test" + tmethod + "() throws Exception {");
      Iterator it = node.iterator();
      int childNumber = 0;
      StringBuilder printBeforeInvocation = new StringBuilder();
      StringBuilder printAfterInvocation = new StringBuilder();
      Map mocks = new HashMap();
      while (it.hasNext()) {
        Node child = (Node) it.next();
        writeDelayed(node, child, out, method, tmethod, childNumber++, mocks, printBeforeInvocation, printAfterInvocation);
      }
      writeTestBodyInit(call, fixtureName, out);
      it = node.iterator();
      Map mockdups = new HashMap();
      while (it.hasNext()) {
        Node child = (Node) it.next();
        MethodEntry childCall = (MethodEntry) child.getObject();
        if (call.getCalleeName() != null && 
           call.getCalleeName().equals(childCall.getCalleeName())) continue;
        if (mockdups.get(childCall.getCalleeName()) != null) continue;
        String mockName = (String) mocks.get(childCall.getCalleeName());

        out.println();
        out.println();
        //out.println("    /////////////////////////////");
        //out.println("    // checking Mock name " + mockName + " in child " + childCall);
        //out.println("    //"); 


        // TODO: Apply reflection here -- search for field with matching type, set protected off and then set field value
        String setter = CodeHelper.getSetterFor(call.getCallee().getClass(), childCall.getCallee().getClass());

	boolean acceptsConstructorForMockInterface = false;
        if (mockName != null && CodeHelper.hasDelegateConstructorFor(call.getCallee().getClass(), childCall.getCallee().getClass())) {
          out.println("    fx = new " + call.getCalleeNameWithoutPackage() + "(" + mockName + ");");
	  acceptsConstructorForMockInterface = true;
        }

        Class childCalleeClass = CodeHelper.getInterfaceFor(childCall.getCallee().getClass());
        if (childCalleeClass == null) childCalleeClass = childCall.getCallee().getClass();
        if (mockName != null && setter != null) {
           if (context.isjMockLibrary()) {
             out.println("    // injecting jMock proxy to the class being test");
             out.println("    fx." + setter + "((" + childCalleeClass.getName() + ") " + mockName + ".proxy());");
           } else {
             out.println("    // injecting EasyMock proxy to the class being test");
             out.println("    fx." + setter + "((" + childCalleeClass.getName() + ") " + mockName + ");");
           }
        } else if (mockName == null) {
           out.println("    /////////////////////////////");
           out.println("    //No mocks for " + childCall.getCalleeName());
        } else {
           out.println("    /////////////////////////////");
           out.println("    //You may need to define following method in " + call.getCalleeName());
           if (setter != null) {	// previously both params were childCall
             if (context.isjMockLibrary()) {
               out.println("    // injecting jMock proxy to the class being test");
               String cast = ""; //"(" + childCalleeClass.getName() + ") ";
               out.println("    fx." + setter + "(" + cast + mockName + ".proxy());");
             } else {
               out.println("    // injecting EasyMock proxy to the class being test");
               String cast = ""; //"(" + childCalleeClass.getName() + ") ";
               out.println("    fx." + setter + "(" + cast + mockName + ");");
             }
           } else {
             if (context.isjMockLibrary()) {
	       if (!acceptsConstructorForMockInterface) {
                 out.println("    //TODO: Add setter method to inject jMock proxy " + childCall.getCalleeNameWithoutPackage() + " to " + call.getCalleeNameWithoutPackage());
                 String cast = ""; //"(" + childCalleeClass.getName() + ") ";
                 out.println("    //fx.set" + childCall.getCalleeNameWithoutPackage() + "(" + cast + mockName + ".proxy());");
	       }
             } else {
	       if (!acceptsConstructorForMockInterface) {
                 out.println("    //TODO: Add setter method to inject EasyMock proxy " + childCall.getCalleeNameWithoutPackage() + " to " + call.getCalleeNameWithoutPackage());
                 String cast = ""; //"(" + childCalleeClass.getName() + ") ";
                 out.println("    //fx.set" + childCall.getCalleeNameWithoutPackage() + "(" + cast + mockName + ");");
	       }
             }
           }
           out.println();
        }
        mockdups.put(childCall.getCalleeName(), Boolean.TRUE);
      }

      ///
      writeTestBodyInvoke(call, out, printBeforeInvocation.toString(), printAfterInvocation.toString());
      out.println("  }"); 
      out.println();
    } catch (Exception e) {
      logger.error("Failed while inspecting (" + node + ")", e);
    }
  }

  /**
   * writeDelayed - checks if any of the method that is invoked from current
   * method can be replaced by mocks and if so it uses jMock/EasyMock to define
   * mocks.
   * @param parent - parent method
   * @param child - current method
   * @param out - output
   * @param method - name of method
   * @param tmethod - name of test method
   * @param childNumber - number of method
   * @param mocks - map of mock objects
   */
  protected void writeDelayed(
        Node parent, 
        Node child, 
        PrintWriter out, 
        String method, 
        String tmethod, 
        int childNumber, 
        Map mocks,
	StringBuilder printBeforeInvocation, 
	StringBuilder printAfterInvocation
        ) throws Exception {
    // obviously no reason to mock class itself.
    MethodEntry childCall = (MethodEntry) child.getObject();
    MethodEntry parentCall = (MethodEntry) parent.getObject();
    if (parentCall.getCalleeName().equals(childCall.getCalleeName())) {
       //out.println("    // Skipping mock for same parent " + parentCall.toMiniString() + " and child " + childCall.toMiniString());
       return;
    }

    boolean setter = (CodeHelper.getSetterFor(parentCall.getCallee().getClass(), childCall.getCallee().getClass()) != null) || CodeHelper.hasDelegateConstructorFor(parentCall.getCallee().getClass(), childCall.getCallee().getClass());

    Class childClass = childCall.getCallee().getClass();
    if (childCall.isObjectMethod()) {
       out.println("    // Skipping object method for parent " + parentCall + " and child " + childCall);
       return; //??? temporary turn off 8/16/06 because I get no last call on a mock available
    }

    boolean interfaceType = childClass.isInterface();

    if (interfaceType) {
      if (childCall.isObjectMethod()) {
        interfaceType = false;
        childClass = Object.class;
        out.println("    // this is call for object method *****");
      }
    } else {
       if (childCall.isObjectMethod()) {
          childClass = Object.class;
       } else {
         Class iface = CodeHelper.getInterfaceFor(childClass);
         if (iface != null) {
	   childClass = iface;
           interfaceType = true;
	 }
       }
    }

    //out.println("    /////////////////");
    //out.println("    // Defining mock for child " + childCall + " of " + parent);

    if (childCall.getModifiers().indexOf("static") != -1) {
       out.println("    /////////////////");
       out.println("    // Skipping mocking static method.");
       out.println();
       return;
    }


    if (!context.useMockForPackage(childCall.getCalleeName())) {
       out.println("    /////////////////");
       out.println("    // Mock for " + childCall.getCalleeName() + " is disabled by the user");
       out.println();
       return;
    }



    if (CodeHelper.getSetterFor(parentCall.getCallee().getClass(), 
            childCall.getCallee().getClass()) == null) {
       //out.println("    /////////////////");
       //out.println("    // Skipping Mock for " + childCall.getCalleeName() + " because setter is not defined in parent " + parentCall.getCalleeName());
       //out.println("    // Ignoring above error, will not skip....");
       //out.println();
       //return;
    }


    String suffix = childCall.getCalleeNameWithoutPackage() + childNumber;


    String mockName = (String) mocks.get(childCall.getCalleeName());
    if (mockName == null) {
       mockName = "mock" + suffix;
       mocks.put(childCall.getCalleeName(), mockName);
       out.println("    /////////////////");
       if (context.isjMockLibrary()) {
         out.println("    // Defining mock for " + childCall.getCalleeNameWithoutPackage() + " using jMock");
         out.println("    Mock " + mockName + " = mock(" + childCall.getCalleeName() + ".class, \"" + mockName + "\");");
       } else {
         if (interfaceType) {
           out.println("    // Defining mock for " + childCall.getCalleeNameWithoutPackage() + " using EasyMock");
           out.print("    " + childClass.getName() + " " + mockName + " = "); 
           if (context.getJavaVersion() < 1.5) out.print("(" + childClass.getName() + ") "); 
           out.println("EasyMock.createStrictControl().createMock(" + childClass.getName() + ".class);"); 
         } else {
           String cast = "(" + childClass.getName() + ") ";
	   if (childClass == Object.class) {
             cast = "";
   	   }
           out.println("    // Defining class mock for " + childCall.getCalleeNameWithoutPackage() + " using EasyMock");
           out.print("    " + childClass.getName() + " " + mockName + " = "); 
           if (context.getJavaVersion() < 1.5) out.print(cast);
           out.println("org.easymock.classextension.EasyMock.createStrictControl().createMock(" + childClass.getName() + ".class);");
         }
       }
    }



    String[] args = childCall.getArgumentTypes(); 
    Object[] argvalues = childCall.getArgumentValues(); 
    StringBuilder sb = new StringBuilder();
    for (int i=0; i<args.length; i++) {
        CodeHelper.declare(context, args[i], argvalues[i], sb, "arg" + suffix + i, mocks);
    }
    out.print(sb.toString());
    sb = new StringBuilder();


    if (!childCall.isVoidMethod()) {
       if (childCall.hasException()) {
          CodeHelper.declare(context, childCall.getException().getClass().getName(), childCall.getException(), sb, "mockException" + suffix, mocks);
          out.print(sb.toString());
          out.println("    //throw new " + childCall.getException().getClass().getName() + "(\"" + childCall.getException() + "\");");
       } else {
          sb = new StringBuilder();
          CodeHelper.declare(context, childCall.getMethodReturnType(), childCall.getReturnValue(), sb, "mockReturn" + suffix, mocks);
          out.print(sb.toString());
       }
    }



    //out.print("    mock.expects(once()).method(\"" + childCall.getMethodName() + "\").with();");
    //expects(times(3).method("name").with...
    //.after(prevMock, "methodName")


    out.println("    // Setting up expectation --  " + childCall.getMethodName() + " will be called");
    if (setter) {
      out.print("    ");
    } else {
      out.println("    //TODO Uncomment following expectation after defining setter or constructor injection for " + parentCall.getCalleeNameWithoutPackage() + ".set" + childCall.getCalleeNameWithoutPackage() + Configuration.LF);
      out.print("    //");
    }


    if (context.isjMockLibrary()) {
      out.print("    " + mockName + ".expects(atLeastOnce()).method(\"" + childCall.getMethodName() + "\").");
    } else {
      if (interfaceType) {
	if (childCall.isVoidMethod()) {
          out.print("    " + mockName + "." + childCall.getMethodName());
	} else {
          out.print("    EasyMock.expect(" + mockName + "." + childCall.getMethodName());
	}
	// instead of specific parameter you can also use EasyMock.notNull()
      } else {
	if (childCall.isVoidMethod()) {
          out.print("    " + mockName + "." + childCall.getMethodName());
	} else {
          out.print("    org.easymock.classextension.EasyMock.expect(" + mockName + "." + childCall.getMethodName());
	}
      }
    }



    if (args.length <= 0) {
      if (context.isjMockLibrary()) {
        out.print("withNoArguments(");
      } else {
        out.print("(");
      }
    } else {
      if (context.isjMockLibrary()) {
        out.print("with(");
      } else {
        out.print("(");
      }
    }
    for (int i=0; i<args.length; i++) {
      if (context.isjMockLibrary()) {
        out.print("eq(arg" + suffix + i + ")");
      } else {
        if (args[i].indexOf("[]") == -1) {
          //out.print("arg" + suffix + i);
          out.print("EasyMock.eq(arg" + suffix + i + ")");
        } else {
          out.print("EasyMock.aryEq(arg" + suffix + i + ")");
        }
      }
      if (i < args.length-1) out.print(",");
    }

    { //if (!childCall.isVoidMethod() && !context.isjMockLibrary()) {
       out.print(")");	// EasyMock for void does not use expect(...
    }


    if (!childCall.isVoidMethod()) {
       if (childCall.hasException()) {
         if (context.isjMockLibrary()) {
           out.println(".will(throwException(mockException" + suffix + ")); // jMock");
         } else {
           out.println(").andThrow(mockException" + suffix + ");");
         }
       } else {
         if (context.isjMockLibrary()) {
           out.println(".will(returnValue(mockReturn" + suffix + ")); // jMock");
         } else {
           out.println(").andReturn(mockReturn" + suffix + ").atLeastOnce();");
         }
       }
    } else {
       if (childCall.hasException()) {
         if (context.isjMockLibrary()) {
           out.println(".will(throwException(mockException" + suffix + ")); // jMock");
         } else {
           out.println(").andThrow(mockException" + suffix + ");");
         }
       } else {
         if (context.isjMockLibrary()) {
            out.println(".isVoid(); //jMock");
         } else {
           out.println(";");
         }
       }
    }
    out.println();
    if (context.isjMockLibrary()) {
    } else {
      if (printBeforeInvocation.indexOf("EasyMock.replay(" + mockName + ");") == -1) {
        if (interfaceType) {
          printBeforeInvocation.append("    EasyMock.replay(" + mockName + ");" + Configuration.LF);
          if (setter) {
            printAfterInvocation.append("    EasyMock.verify(" + mockName + ");" + Configuration.LF);
	  } else {
            printAfterInvocation.append("    //TODO Uncomment following verify after defining setter or constructor injection for " + parentCall.getCalleeNameWithoutPackage() + ".set" + childCall.getCalleeNameWithoutPackage() + Configuration.LF);
            printAfterInvocation.append("    //EasyMock.verify(" + mockName + ");" + Configuration.LF);
	  }
          printAfterInvocation.append("    EasyMock.reset(" + mockName + ");" + Configuration.LF);
        } else {
          printBeforeInvocation.append("    org.easymock.classextension.EasyMock.replay(" + mockName + ");" + Configuration.LF);
          if (setter) {
            printAfterInvocation.append("    org.easymock.classextension.EasyMock.verify(" + mockName + ");" + Configuration.LF);
	  } else {
            printAfterInvocation.append("    //TODO Uncomment following verify after defining setter or constructor injection for " + parentCall.getCalleeNameWithoutPackage() + ".set" + childCall.getCalleeNameWithoutPackage() + Configuration.LF);
            printAfterInvocation.append("    //org.easymock.classextension.EasyMock.verify(" + mockName + ");" + Configuration.LF);
	  }
          printAfterInvocation.append("    org.easymock.classextension.EasyMock.reset(" + mockName + ");" + Configuration.LF);
        }
      }
    }
  }


  ////////////////////////////////////////////////////////////////////
  //
  private static Tree getTree() {
    Tree tree = (Tree) methodStacks.get();
    return tree;
  }

  private Map tmethodMap = new HashMap();

  private static ThreadLocal methodStacks = new ThreadLocal() {
    protected Object initialValue() {
       return new Tree();
    }
  };
}

